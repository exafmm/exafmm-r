#pragma once
#include "type.h"
#include "mathfunc.h"
#include "align.h"
#include <map>
#include "tree.h"
#include "argument.h"
#include "surface.h"
#include <fftw3.h>
#include "c2c.h"

namespace rtfmm
{

class LaplaceKernel
{
public:
    void direct(Bodies& bs_src, Bodies& bs_tar, int images, real cycle);
    void p2p(Cells& cs, std::vector<int>& p2ps, Cell& cell_tar);
    void p2m(int P, Cell& csrc);
    void m2m(int P, Cell& c, Tree& tree);
    void l2l(int P, Cell& c, Tree& tree);
    void l2p(int P, Cell& ctar);
    void m2l(int P, Cells& cs, std::map<int, std::vector<int>>& m2l_parent_map);
    void m2p(int P, Cell& cell_src, Cell& cell_tar);
    void p2l(int P, Cell& cell_src, Cell& cell_tar);

    void precompute(int P, real r0, int images);
    void precompute_m2l(int P, real r0, int images);

    Matrix get_p2p_matrix(
        std::vector<vec3r>& x_src, 
        std::vector<vec3r>& x_tar
    );

    /**
     * @brief convert vec3i to hashed value
     * @return hash value, for example, (-1,-2,3) -> 1236, where 6=110 means negative for 1 and 2
    */
    static int hash(rtfmm::vec3i v)
    {
        int signs = ((v[0] < 0 ? 1 : 0) << 2) + ((v[1] < 0 ? 1 : 0) << 1) + (v[2] < 0 ? 1 : 0);
        int coord = std::abs(v[0]) * 1000 + std::abs(v[1]) * 100 + std::abs(v[2]) * 10;
        return coord + signs;
    }

    /**
     * @brief Get a hash(relx) -> index map.
     * For each coordinate x in [-range,+range]^3 >= minv, give it a unique index for hash(x).
     * @note The main usage of the returned map is to link an interaction pair to a precomputed interaction matrix.
     * For example, when coordinates of two cells in a M2L pair is given, say xsrc and xtar, the M2L matrix is map[hash(xsrc-xtar)].
    */
    static std::map<int,int> get_relx_idx_map(int range, int minv)
    {
        std::map<int, int> res;
        int cnt = 0;
        for(int k = -range; k <= range; k++)
        {
            for(int j = -range; j <= range; j++)
            {
                for(int i = -range; i <= range; i++)
                {
                    if(std::abs(i) >= minv || std::abs(j) >= minv || std::abs(k) >= minv)
                    {
                        res[hash(vec3i(i,j,k))] = cnt;
                        cnt++;
                    }
                }
            }
        }
        return res;
    }

    /**
     * @brief Get coorinates in [-range,+range]^3 >= minv.
     * @note when same parameters are passed, coordinates returned by this function and indices returned by get_relx_idx_map are one-to-one mathced.
     * For example, [1,-1,-1] is the 2th coordinates generated by get_relx(1,1), 
     * at the same time, index corresponding to hash([1,-1,-1]) is 2 for map from get_relx_idx_map(1,1)
    */
    template<typename T>
    static std::vector<vec<3,T>> get_relx(int range, int minv)
    {
        std::vector<vec<3,T>> res;
        for(int k = -range; k <= range; k++)
        {
            for(int j = -range; j <= range; j++)
            {
                for(int i = -range; i <= range; i++)
                {
                    if(std::abs(i) >= minv || std::abs(j) >= minv || std::abs(k) >= minv)
                    {
                        res.push_back(vec<3,T>(i,j,k));
                    }
                }
            }
        }
        return res;
    }

    static std::vector<rtfmm::real> get_G_matrix(std::vector<rtfmm::vec3r>& grid, int N)
    {
        std::vector<rtfmm::real> G;
        for(int k = 0; k < N; k++)
        {
            for(int j = 0; j < N; j++)
            {
                for(int i = 0; i < N; i++)
                {
                    rtfmm::real r = grid[k * N * N + j * N + i].r();
                    rtfmm::real invr = r == 0 ? 0 : 1 / r;
                    G.push_back(invr);
                }
            }
        }
        return G;
    }

public:
    Matrix UT_p2m_precompute;
    Matrix V_p2m_precompute;
    Matrix Sinv_p2m_precompute;
    Matrix VSinv_p2m_precompute;

    Matrix matrix_m2m[8];
    Matrix matrix_l2l[8];

    Matrix UT_l2p_precompute;
    Matrix V_l2p_precompute;
    Matrix Sinv_l2p_precompute;
    Matrix VSinv_l2p_precompute;
    Matrix VSinvUT_l2p_precompute;

    std::map<int, std::vector<complexr>> m2l_Gks;
    /**
     * @brief matrix vector storing 8x8 child-child interaction Gk of 2 neighbour cells
     * @note ### number of matrix = 26, size of each matrix = N_freq * 8 * 8 * complex
    */
    std::vector<AlignedVec> ccGks_8x8;

private:
    void hadamard_8x8(
        int fft_size, 
        conv_grid_setting& cgrid,
        std::vector<size_t>& interaction_count_offset_8x8,
        std::vector<size_t>& interaction_offset_f_8x8,
        AlignedVec& Qk_all, 
        AlignedVec& Pk_all
    );

    /*void hadamard_1x27(
        int fft_size, 
        conv_grid_setting& cgrid,
        std::vector<size_t>& interaction_count_offset_1x27,
        std::vector<size_t>& interaction_offset_f_1x27,
        AlignedVec& Qk_all, 
        AlignedVec& Pk_all
    );*/
};

}